(* ::Package:: *)

(* ::Title:: *)
(*VQE on a VQD*)


(* ::Subtitle:: *)
(*Full density matrix simulation*)


(* ::Subsection:: *)
(*Other modules*)


(* ::Input:: *)
(*FormatHamiltonian::usage="Format the hamiltonian from qiskit to questlink";*)
(**)
(*FormatHamiltonian[filename_]:=Module[*)
(*{stringham,ham,nterms,nqubits}*)
(*,*)
(*stringham = Import[filename];*)
(*ham = ToExpression[stringham];*)
(*nqubits = 1 + Select[Flatten[Level[#, -1]& /@Flatten @ ham], NumericQ[#]&]//Max;*)
(*ham=*)
(*Table[*)
(*If[Length[term] < 2*)
(*,*)
(*{term[[1]], Subscript[Id, nqubits-1]}, term]*)
(*,{term, ham}];*)
(*nterms = Length @ ham;*)
(*{Total @ Apply[Times, ham, 1], nterms, nqubits}*)
(*]*)


(* ::Subsubsection:: *)
(*Default hyperparameters and initial state preparation : this setting is optimised for H2 simulation on SQC*)


(* ::Input:: *)
(*CustomGatesDefinitions={*)
(*(**)
(*Subscript[SWAP, p_,q_]:>Sequence@@{Subscript[Rx, p][\[Pi]/2],Subscript[C, p][Subscript[Z, q]],Subscript[Rx, p][\[Pi]/2],Subscript[Rx, q][\[Pi]/2],Subscript[C, p][Subscript[Z, q]],Subscript[Rx, p][\[Pi]/2],Subscript[Rx, q][\[Pi]/2],Subscript[C, p][Subscript[Z, q]],Subscript[Rx, p][\[Pi]/2]}*)
(*,*)
(**)*)
(*(*SQC swap sequence*)*)
(*Subscript[SWAP, i_,j_]:>Sequence[Subscript[Rx, i][\[Pi]/2],Subscript[Ry, j][-(\[Pi]/2)],Subscript[ZZ, i,j],Subscript[Ry, i][-(\[Pi]/2)],Subscript[Rx, j][\[Pi]/2],Subscript[ZZ, i,j],Subscript[Ry, j][-(\[Pi]/2)],Subscript[Rx, i][\[Pi]/2],Subscript[ZZ, i,j]]*)
(*,Subscript[PSW, index1_,index2_][\[Theta]_]:>Subscript[U, index1,index2][{{1,0,0,0},{0,E^((I \[Theta])/2) Cos[\[Theta]/2],-I E^((I \[Theta])/2) Sin[\[Theta]/2],0 },{0,-I E^((I \[Theta])/2) Sin[\[Theta]/2], E^((I \[Theta])/2) Cos[\[Theta]/2],0 }{0,0,0,1}}]*)
(*}; *)
(*CustomGatesDraw={Subscript[PSW, index1_,index2_][_]:>Subscript[SWAP, index1,index2],Subscript[ZZ, p_,q_]:>Subscript[C, p][Subscript[Z, q]],Subscript[ZZ, p_,q_][\[Theta]_]:>Subscript[C, p][Subscript[Ph, q][\[Theta]]],Subscript[ZX, p_,q_][_]:>Subscript[ZX, p,q],Subscript[ZZ, p_,q_][\[Theta]]:>Subscript[C, p][Subscript[Ph, q][\[Theta]]]};*)


(* ::Input:: *)
(*DefaultConfig::usage="DefaultConfig[virtual_device,hamiltonian,[device2]] return default config.";*)
(*DefaultConfig[vdev_,hamiltonian_,vdev2_:None]:=Module[{nqubit=vdev[NumAccessibleQubits],hammat=CalcPauliStringMatrix[hamiltonian]},*)
(*<|*)
(*(* The virtual device *)*)
(*"device"->vdev,*)
(*(* The virtual device with doubled errors  *)*)
(*"device2"->vdev2,*)
(*(* Parallelisation of gates *)*)
(*"parallel"->False,*)
(*(* Initial circuit, usually corresponds to qubits initialisation *)*)
(*"initcirc"->{Subscript[Init, 0,1,2,3]},*)
(*(* Virtual measurement appended at the end of the circuit, this corresponds to the errors in the measurement without performing the measurement itself *)*)
(*"virtualmeas"->(Subscript[Depol, #][1-OptionValue[SuperconductingHub,FidRead][#]]&/@Range[0,nqubit-1]),*)
(*(* Number of physical qubit *)*)
(*"nqubit"-> nqubit,*)
(*(* Methods to calcualte gradient: NGCD || GPS || NGAN || GCD || NGP || GSTO || GPSTO *)*)
(*"grad"->"NGAN",*)
(*(* If the ansatz is fixed. Use \[Theta] as free parameters. Works without subscript if fixansatzparam is not set *)*)
(*"ansatz"->{},*)
(*(* If you want to set the initial params of the fix ansatz *)*)
(*"\[Theta]vars"-><||>,*)
(*(* Number of failure/convergence to lower the energy in a cycle *)*)
(*"globalconverge"-> 4,*)
(*(* Number of gates thrown at most for the maximum cost *)*)
(*"ngatesinit"->10,*)
(*(* Speedinng up first or slowing down *)*)
(*"speedupfirst"->True,*)
(*(* depth of parameterized swap *)*)
(*"swapfabricdepth"->0,*)
(*(* Max iteration in relaxation *)*)
(*"maxiter"->10000,*)
(*(* Maximum iteration for bruteforce on each removal of gates *)*)
(*"maxbfiter"->4000,*)
(*(* Maxpimum iteration on each pruning methode, apart from brute-force*)*)
(*"maxpruneiter"->4000,*)
(*(* maximum iteration for greedy search *)*)
(*"maxgreediter"-> 1000,*)
(*(* Set the groundstate cost, please recalculate first *)*)
(*"groundstate"->Min@Eigenvalues@CalcPauliStringMatrix@hamiltonian,*)
(*(* hamiltonian as sum of Z *)*)
(*"hamiltonian"->hamiltonian,*)
(*(* the hamiltonian matrix *)*)
(*"hammat"->hammat,*)
(*(* The qubits allowed to search for ansatz *)*)
(*"ansatzspace"->  Range[0,nqubit-1],*)
(*(* The choice of ansazte provided on each cycle *)*)
(*"greediness"->8,*)
(*(* Greediness in the first cycle *)*)
(*"greedinessinit"->5,*)
(*(* Plateau in the greedy by fraction energy improvement, not perfection *) *)
(*"greedflat"->10^-9,     *)
(*  (* Fixed step in the gradient direction *)   *)
(*"gradstep"->10^-4,*)
(*(* Multiplications of gradient step that is tried out, natural gradient. Set it to False to switch it off *)*)
(*"gradstepmultiply"->1.2,*)
(*(* Tikhonov regularization constant, natural gradient, doesn't matter that much *)*)
(*"\[Alpha]tikhonov"->10^-3,*)
(*(* Norm of between two rows of the metric A that leads to deletion*)*)
(*"metignore"->10^-3,   *)
(*(* Detect flatness as convergence. *)*)
(*"perfectingflat"->10^-8,*)
(*(* Error allowed to increase energy in the pruning *)*)
(*"pruningerror"->0.05,*)
(*(* The number of convergence to stop variational iteration *)*)
(*"iterconverge"->5,*)
(*(* new gates with param \[Theta] are initialized with [-\[Theta]initrange,\[Theta]initrange]\[ReverseElement]\[Theta] *)*)
(*"\[Theta]initrange"->\[Pi]/4,*)
(*(* The number of trial in guessing random initial \[Theta]*)*)
(*"greed\[Theta]"->3,*)
(*(* Optimisation done to pick the best set of initial \[Theta]*)*)
(*"g\[Theta]iter"->5,*)
(*(* target to the final cost *)*)
(*"\[Epsilon]fin"->1*10^-6,*)
(*(* Proportion throwing 1-,2-, qubit gates*)*)
(*"weightgate"->{1-> 0.8,2->0.2},*)
(*(* The used gate set by default; it has form of <|1->{}, 2->{}, "dyn"->{dynamic_mult_qubit_gates}|>, with key as n-qubit gates *)*)
(*"gateset"-><|1->{Subscript[Rx, #][\[Theta]]&,Subscript[Ry, #][\[Theta]]&,Subscript[Rz, #][\[Theta]]&},2->{Subscript[ZZ, #,#2]&,Subscript[ZX, #,#2]&}|>,*)
(*(* default connectivity on the device as a graph as function that returns graph or a graph. The gate is identified by some hash number *)*)
(*"connectivity"->Function[{gate},If[Hash[gate]===Hash[Subscript[ZX, #,#2]&],vdev[Connectivity],UndirectedGraph@vdev[Connectivity]]],*)
(*(* *)
(*The swap operator to overcome the connectivity problem or create swap substrate. Set to None/False to turn not using it.*)
(**)*)
(*"swap"->None(*Function[{i,j},Subscript[SWAP, i,j]]*)*)
(*,*)
(*(* *)
(*When it is set, the algorithm will perform two-steps compilation by connecting the undoable gates via swaps. Set the gates that have full connectivity*)
(**)*)
(*"fullconn"->{}*)
(*|>*)
(*]*)


(* ::Input:: *)
(*Hash[Subscript[ZZ, #,#2]&]*)
(*Hash[Subscript[ZX, #,#2]&]*)
(*Hash[Subscript[ZX, #,#2][\[Theta]]&]*)


(* ::Input:: *)
(*HPsummary::usage="HPsummary[conf] the summary of hyperparameters used in the computation";*)
(*HPsummary[conf_]:=Table[k->conf[k],{k,Complement[Keys@conf,{"device","undocirc","hamiltonian","hammat"}]}]*)


(* ::Input:: *)
(*SwapFabric::usage="SwapFabric[nqubit, depth, initrange]. Create a fabric of parameterized swaps tailored to the virtual device. It usualy involves location permutation and alter the allowed permutation of gates completely. *)
(*Return {ansatz,\[Theta]vars,index}*)
(*";*)
(*SwapFabric[nqubit_,devicetype_,depth_]:=Module[*)
(*{ansatz={},\[Theta]vars=<||>,loop,loop2},*)
(*For[loop=1,loop<=2*depth,loop++,*)
(*For[loop2=Mod[loop,2],loop2<nqubit-1,loop2+=2,*)
(*AppendTo[ansatz,swapGate[devicetype][loop2,loop2+1]]*)
(*]*)
(*];*)
(*ansatz*)
(*]*)


(* ::Input:: *)
(*swapGate::usage="swapGate[devicename]. Return the legal swap gate per device as a function of qubit indices";*)
(*swapGate[devicetype_String]:=Which[*)
(*devicetype==="SiliconDelft",*)
(*Subscript[SWAP, #,#2]&*)
(*,*)
(*devicetype==="Toy",*)
(*Subscript[PSW, #,#2][\[Theta]]&*)
(*,*)
(*True*)
(*,*)
(*Subscript[SWAP, #,#2]&*)
(*]*)
(**)
(*(* Expected devices: *)
(*"SiliconDelft","SiliconHub","SuperconductingFZJ","SuperconductingHub","TrappedIonOxford","TrappedIonInnsbruck","RydbergHub","RydbergWisconsin","NVCenterDelft","NVCenterHub"*)
(**)*)
(*gateSetDevice[devicetype_String]:=Which[*)
(*devicetype==="SiliconDelft",*)
(*<|1->{Subscript[Rx, #][\[Theta]]&,Subscript[Ry, #][\[Theta]]&},2->{Subscript[C, #][Subscript[Ph, #2][\[Theta]]]&}|>*)
(*,*)
(*devicetype==="TrappedIonsOxford",*)
(*{}*)
(*,*)
(*devicetype==="Toy",*)
(*<|1->{Subscript[Rx, #][\[Theta]]&,Subscript[Ry, #][\[Theta]]&,Subscript[Rz, #][\[Theta]]&},2->{Subscript[C, #][Subscript[Rx, #2][\[Theta]]]&,Subscript[C, #][Subscript[Ry, #2][\[Theta]]]&,Subscript[C, #][Subscript[Rz, #2][\[Theta]]]&,Subscript[PSW, #,#2][\[Theta]]&}|>*)
(*,*)
(*True*)
(*,*)
(*Print["device "<>devicetype<>" not found. Use generic gates set instead."];*)
(*{Subscript[Rx, #][\[Theta]]&,Subscript[Ry, #][\[Theta]]&,Subscript[Rz, #][\[Theta]]&,Subscript[C, #][Subscript[Rx, #2][\[Theta]]]&,Subscript[C, #][Subscript[Ry, #2][\[Theta]]]&,Subscript[C, #][Subscript[Rz, #2][\[Theta]]]&}*)
(*]*)
(**)
(*gateConnectivity::usage="gateConnectivity[device]. Return graph describing connectivity";*)
(*gateConnectivity[device_]:=Module[{nq},*)
(*nq=device[NumAccessibleQubits];*)
(*Which[*)
(*device[DeviceType]==="SiliconDelft",*)
(*Graph[#-1->#& /@Range[nq-1],VertexLabels->Placed[Automatic,Center],VertexSize->Small]*)
(**)
(*,*)
(*device[DeviceType]==="Toy",*)
(*Graph[#-1\[UndirectedEdge]#& /@Range[nq-1],VertexLabels->Placed[Automatic,Center],VertexSize->Small]*)
(*,*)
(*True*)
(*,*)
(*(*fully connected graph by default*)*)
(*AdjacencyGraph[Range[0,nq-1],AdjacencyMatrix@CompleteGraph[nq],VertexLabels->Placed[Automatic,Center],VertexSize->Small]*)
(*]*)
(*]*)


(* ::Subsection:: *)
(*Random gates generation related*)


(* ::Subsubsection::Closed:: *)
(*Random gates generation based on connectivity*)


(* ::Input:: *)
(*singleRGate[conf_]:=Module[*)
(*{pool, gate,qubit},*)
(*(* potentially construct preferable gate operation *)*)
(*pool=conf["gateset"][1];*)
(*pool=RandomSample[pool]; (* randomly permute*)*)
(*gate=RandomChoice[pool];*)
(*(*potentially add subspace *)*)
(*qubit=RandomChoice[conf["ansatzspace"]];*)
(*gate[qubit]*)
(*]*)
(**)
(*twoRGate[conf_]:=Module[{pool,qubits,getcon,conn,gate,path={}},*)
(*pool=conf["gateset"][2];*)
(*pool=Permute[pool,RandomPermutation@Length@pool];*)
(*gate=RandomChoice[pool];*)
(*getcon[con_List]:=con;*)
(*(*gate-dependent connectivity*)*)
(*getcon[con_Function]:=con[gate];*)
(**)
(*conn=getcon[conf["connectivity"]];*)
(*If[MemberQ[conf["fullconn"],gate],*)
(*gate@@RandomSample[conf["ansatzspace"],2]*)
(*,*)
(*gate@@If[GraphQ[conn],List@@RandomChoice[EdgeList[conn]],conn]*)
(*]*)
(*]*)
(*multiRGate::usage="multiRGate. Draw random n-qubit gates. Reserved for neutral atom";*)
(*multiRGate[]:=Module[{},{}]*)


(* ::Subsubsection::Closed:: *)
(*Generate/extending ansatz*)


(* ::Text:: *)
(*f[x]:=Subscript[g, min] E^\[Lambda]x*)
(*Subscript[g, max]=Subscript[g, min] E^Subscript[\[Lambda]x, max]*)
(*\[Lambda]=Log[Subscript[g, max]/Subscript[g, min]]/Subscript[x, max]*)


(* ::Input:: *)
(*dynNGates::usage="dynNGates[costmax,cost,ngatesinit,groundstate]. Determine the number of gates thrown";*)
(*dynNGates[costmax_,cost_,ngatesinit_,groundstate_]:=Module[*)
(*{gmax=ngatesinit,*)
(*gmin=Ceiling[0.5*ngatesinit],(*50% at convergence*)*)
(*xmax=costmax-groundstate,*)
(*\[Lambda]},*)
(*\[Lambda]=Log[gmax/gmin]/xmax;*)
(*Min[Ceiling[gmin*E^(\[Lambda](cost-groundstate))],ngatesinit]*)
(*]*)


(* ::Input:: *)
(*RandomGate[conf_,probzeros_,qmiavg_]:=With[*)
(*{nq=RandomChoice[Values@conf["weightgate"]->Keys@conf["weightgate"]]},*)
(*Which[*)
(*nq===1,*)
(*singleRGate[conf,probzeros]*)
(*,*)
(*nq===2,*)
(*twoRGate[conf,qmiavg]*)
(*,*)
(*True,*)
(*multiRGate[]*)
(*]*)
(*]*)
(**)
(*RandomGate[conf_]:=With[{nq=RandomChoice[Values@conf["weightgate"]->Keys@conf["weightgate"]]},*)
(*Which[*)
(*nq===1,*)
(*singleRGate[conf]*)
(*,*)
(*nq===2,*)
(*twoRGate[conf]*)
(*,*)
(*True,*)
(*multiRGate[]*)
(*]*)
(*]*)


(* ::Input:: *)
(*ClearAll[RandomAnsatz]*)


(* ::Input:: *)
(*RandomAnsatz::usage="RandomAnsatz[conf, ngates]. Generate random ansatz";*)
(*RandomAnsatz[conf_,ngates_, args___]:=Module[{linit=0,ansatztmp={},rgates,method,sloc},*)
(*(* method: 1-global, 2-appended, 3-prepended *)*)
(*method=RandomChoice[{1,2,3} ];*)
(**)
(*While[Length@ansatztmp<ngates,*)
(*(*introduce random gates*)*)
(*rgates=Flatten@{RandomGate[conf,args]};*)
(*(*location of new gates*)*)
(*Which[*)
(*method===1,*)
(*sloc=RandomChoice[Range[Length@ansatztmp+1]];*)
(*Table[ansatztmp=Insert[ansatztmp,g,sloc],{g,rgates}];*)
(*method===2,*)
(*ansatztmp=Join[rgates,ansatztmp];*)
(*method===3,*)
(*ansatztmp=Join[ansatztmp,rgates]*)
(*]*)
(*];*)
(*ansatztmp*)
(*]*)


(* ::Input:: *)
(*ExtendAnsatz::usage="ExtendAnsatz[idx, conf, ansatz, naddgates].*)
(*Extend ansatz by adding naddgates gates. There is no redundancy check here. *)
(*Arguments aren't changed, except the start index. Return the new ansatz candidate.*)
(*Ansatz is done 50% globally spread, 25% appended at the end, and 25% appended in the begining.*)
(*Return: extended ansatz*)
(*";*)
(*SetAttributes[ExtendAnsatz,HoldFirst]*)
(*ExtendAnsatz[idx_,conf_,ansatz_,naddgates_,args___]:=Module[{linit=Length@ansatz,ansatztmp=ansatz,rgates,method,ngates,ngatestotal,sloc},*)
(*(* method: 1-global, 2-appended, 3-prepended *)*)
(*method=RandomChoice[{1,2,3} ];*)
(*ngatestotal=naddgates+Length@ansatz;*)
(**)
(*While[Length@ansatztmp<ngatestotal,*)
(*(*introduce random gates*)*)
(*rgates=Flatten@{RandomGate[conf,args]};*)
(*(*location of new gates*)*)
(*Which[*)
(*method===1,*)
(*sloc=RandomChoice[Range[Length@ansatztmp+1]];*)
(*Table[ansatztmp=Insert[ansatztmp,g,sloc],{g,rgates}];*)
(*method===2,*)
(*ansatztmp=Join[rgates,ansatztmp];*)
(*method===3,*)
(*ansatztmp=Join[ansatztmp,rgates]*)
(*]*)
(*];*)
(**)
(*ReplaceAll[ansatztmp,*)
(*{\[Theta]_Subscript:>\[Theta], (*avoid ones with subcript*)*)
(*\[Theta]:>Subscript[\[Theta], idx++]}]*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Indices - related modules*)


(* ::Input:: *)
(*GetIndicesOfGate::usage="GetIndicesOfGate[gate_] return indices of the corresponding qubits, watch for exotic gates, it might fail!";*)
(*GetIndicesOfGate[gate_]:=gate/.{_[_,Subscript[_, i_] Subscript[_, j_]]:>{i,j},Subscript[C, i_][Subscript[_, j_]]:>{i,j},Subscript[_, i__][Subscript[_, j_][_]]:>{i,j},Subscript[_, i__][_]:>{i},Subscript[_, i__]:>{i}}*)
(**)
(**)
(*GetAssocGates::usage="GetAssocGates[ansatz_,assocgatesref_] return association version of gates -- per layer. It might works only for 1 and 2-qubit gates ";*)
(*SetAttributes[GetAssocGates,HoldRest]*)
(*GetAssocGates[ansatz_,assocgatesref_]:=Module[{indices,key,idxs},*)
(*Table[*)
(*indices=ToString[#]&/@GetIndicesOfGate[gate];*)
(*key=StringRiffle[Sort@indices,"-"];*)
(*If[\[Not]KeyExistsQ[assocgatesref,key],assocgatesref[key]={}];*)
(**)
(*(* put also gates in the overlaping cases *)*)
(*idxs={key,indices}//Flatten//DeleteDuplicates;*)
(*Table[*)
(* If[IntersectingQ[idxs,StringSplit[k,"-"]],*)
(*AppendTo[assocgatesref[k],gate]]*)
(*,*)
(*{k,Keys@assocgatesref}];*)
(*,{gate,ansatz}]*)
(*]*)
(**)
(*(* temporary solution *)*)
(*IsOneQGate::usage="IsOneQGate[gate_] tells if gate is a one-qubit rotation ";*)
(*IsOneQGate[g_]:=If[Or@@(MatchQ[g,#]&/@{Subscript[Rx, _][_],Subscript[Ry, _][_],Subscript[Rz, _][_],Subscript[Ph, _][_],Subscript[X, _],Subscript[Y, _],Subscript[Z, _],Subscript[H, _]}),1,2]*)
(*IsControlQubit::usage="IsControlQubit[gate_] tells if a gate is Controlled-Rotation gate";*)
(*IsControlQubit[g_]:=If[MatchQ[g,Subscript[C, _][_]],1,0]*)


(* ::Subsection:: *)
(*Gradient evaluations and optimization*)


(* ::Subsubsection::Closed:: *)
(*Gradients*)


(* ::Input:: *)
(*GradFiniteDiff::usage="GradCentralDiff[conf, \[Theta]vars, noisy_ansatz, \[Rho], \[Rho]work]. Calculate gradient with central difference wrt cost function.";*)
(*SetAttributes[GradFiniteDiff,HoldAll]*)
(*GradFiniteDiff[conf_,\[Theta]vars_,nansatz_,\[Rho]_,\[Rho]work_]:=Module[{grad,baseE,\[Theta]varst,d\[Theta]=10^-6},*)
(*baseE=costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]vars,conf];*)
(*grad=Table[*)
(*\[Theta]varst=\[Theta]vars;*)
(*\[Theta]varst[k]+=d\[Theta];*)
(*(costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varst,conf]-baseE)/d\[Theta],*)
(*{k,Keys[\[Theta]vars]}];*)
(*grad/Max[Norm[grad],10^-10]*)
(*]*)
(**)
(*GradCentralDiff::usage="GradCentralDiff[conf, \[Theta]vars, noisy_ansatz, \[Rho], \[Rho]work]. Calculate gradient with finite difference wrt cost function.";*)
(*SetAttributes[GradCentralDiff,HoldAll]*)
(*GradCentralDiff[conf_,\[Theta]vars_,nansatz_,\[Rho]_,\[Rho]work_]:=Module[{grad,\[Theta]varst2,\[Theta]varst,d\[Theta]=10^-6},*)
(*grad=Table[*)
(*\[Theta]varst=\[Theta]vars;*)
(*\[Theta]varst2=\[Theta]vars;*)
(*\[Theta]varst[k]+=d\[Theta];*)
(*\[Theta]varst2[k]-=d\[Theta];*)
(*(costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varst,conf]-costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varst2,conf])*0.5/d\[Theta],*)
(*{k,Keys[\[Theta]vars]}];*)
(*grad/Max[Norm[grad],10^-10]*)
(*]*)
(**)
(*GradCentralDiffStochastic::usage="GradDescentStochastic[conf, \[Theta]vars, ansatz, \[Rho], \[Rho]work]";*)
(*SetAttributes[GradCentralDiffStochastic,HoldAll]*)
(*GradCentralDiffStochastic[conf_,\[Theta]vars_,nansatz_,ansatz_,\[Rho]_,\[Rho]work_]:=Module[{grad,baseE,\[Theta]varst,newvals,gradclean,gradnoise,noise},*)
(*gradclean=GradCentralDiff[conf,\[Theta]vars,ansatz,\[Rho],\[Rho]work];*)
(*gradnoise=GradCentralDiff[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work];*)
(**)
(*(* make the noise normalised with \[Mu]=0 *)*)
(*noise=Normalize[(gradclean-gradnoise)];*)
(*noise-=Mean[noise];*)
(*grad=gradclean+noise;*)
(*grad(*/Max[Norm[grad],10^-10]*)*)
(*]*)
(**)
(*GradFiniteDiffStochastic::usage="GradDescentStochastic[conf, \[Theta]vars, ansatz, \[Rho], \[Rho]work]";*)
(*SetAttributes[GradFiniteDiffStochastic,HoldAll]*)
(*GradFiniteDiffStochastic[conf_,\[Theta]vars_,nansatz_,ansatz_,\[Rho]_,\[Rho]work_]:=Module[{grad,baseE,\[Theta]varst,newvals,gradclean,gradnoise,noise},*)
(*gradclean=GradFiniteDiff[conf,\[Theta]vars,ansatz,\[Rho],\[Rho]work];*)
(*gradnoise=GradFiniteDiff[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work];*)
(**)
(*(* make the noise normalised with \[Mu]=0 *)*)
(*noise=Normalize[(gradclean-gradnoise)];*)
(*noise-=Mean[noise];*)
(*grad=gradclean+noise;*)
(*grad*)
(*]*)
(**)
(**)
(*GradPS::usage="Calculate the gradient with parameter shift approach wrt cost average; not working for exotic gates ";*)
(*GradPS[conf_,\[Theta]vars_,nansatz_,\[Rho]_,\[Rho]work_]:=Module[{\[Theta]varsp,\[Theta]varsm,grad},*)
(*grad=Table[*)
(*\[Theta]varsp=\[Theta]vars;*)
(*\[Theta]varsm=\[Theta]vars;*)
(*\[Theta]varsm[k]-=\[Pi]/2;*)
(*\[Theta]varsp[k]+=\[Pi]/2;*)
(*(costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varsp,conf]-costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varsm,conf])/2,*)
(*{k,Keys[\[Theta]vars]}];*)
(*grad/Max[Norm[grad],10^-10]*)
(*]*)
(**)
(**)
(*NaturalGradAnalytic::usage="Calculate the natural gradient with Tyson analytic approach in calculating d\[Rho]/d\[Theta] ";*)
(*NaturalGradAnalytic[conf_,\[Theta]vars_,nansatz_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_]:=Module[{NG,Fkl,dE,r\[Theta]k,\[Theta]varst,d\[Rho],dcost,baseE,m\[Rho],tvars,assumptions,sansatz},*)
(*tvars=Normal@\[Theta]vars;*)
(*assumptions=(If[#[[2]]>0,#[[1]]>0,#[[1]]<0]&)/@tvars;*)
(*sansatz=Simplify[nansatz[[1]],Assumptions->assumptions];*)
(**)
(*(* d\[Rho]/Subscript[d, j]\[Theta] *)*)
(*ApplyCircuitDerivs[InitZeroState@\[Rho],sansatz,tvars,\[Rho]\[Theta]k];*)
(*(*  Use first approximation of QFI: Subscript[F, kl]=Tr[(d\[Rho]/Subscript[d\[Theta], k])(d\[Rho]/Subscript[d\[Theta], l])]*)*)
(*Fkl=Re@CalcDensityInnerProducts[\[Rho]\[Theta]k];*)
(*(*dE/Subscript[d\[Theta], j]*)*)
(*ApplyCircuit[\[Rho],sansatz/.\[Theta]vars];*)
(*ApplyPauliString[\[Rho],conf["hamiltonian"],\[Rho]work];*)
(*dE=CalcDensityInnerProducts[\[Rho]work,\[Rho]\[Theta]k]//Re;*)
(*(* The natural gradient: F^-1g *)*)
(*NG=Fit[{Fkl,dE},FitRegularization->{"Tikhonov",conf["\[Alpha]tikhonov"]}];*)
(*NG/Max[Norm[NG,2],10^-10]*)
(*]*)
(**)
(**)
(*GradPStochastic::usage="Calculate the gradient with parameter shift approach wrt cost average; not working for exotic gates ";*)
(*GradPStochastic[conf_,\[Theta]vars_,nansatz_,ansatz_,\[Rho]_,\[Rho]work_]:=Module[{\[Theta]varsp,\[Theta]varsm,gradclean,gradnoise,noise,assumptions,grad},*)
(*gradclean={};gradnoise={};*)
(**)
(*Table[*)
(*\[Theta]varsp=\[Theta]vars;*)
(*\[Theta]varsm=\[Theta]vars;*)
(*\[Theta]varsm[k]-=\[Pi]/2;*)
(*\[Theta]varsp[k]+=\[Pi]/2;*)
(*AppendTo[gradclean,(costAvg[\[Rho],\[Rho]work,ansatz/.\[Theta]varsp,conf]-costAvg[\[Rho],\[Rho]work,ansatz/.\[Theta]varsm,conf])/2];*)
(*AppendTo[gradnoise,(costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varsp,conf]-costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]varsm,conf])/2];*)
(*,*)
(*{k,Keys[\[Theta]vars]}];*)
(**)
(*(* make the noise normalised with \[Mu]=0 *)*)
(*noise=Normalize[(gradclean-gradnoise)];*)
(*noise-=Mean[noise];*)
(*grad=(gradclean+noise);*)
(**)
(*grad/Max[Norm[grad],10^-10]*)
(*]*)
(**)
(**)
(*NaturalGradAnalyticStochastic::usage="NaturalGradAnalyticStochastic[conf,\[Theta]vars,noisy_ansatz,ansatz,\[Rho],\[Rho]work,\[Rho]\[Theta]k]. Gradient + stochastic noise obtained from the virtual device.";*)
(*NaturalGradAnalyticStochastic[conf_,\[Theta]vars_,nansatz_,ansatz_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_]:=Module[{NG,Fkl,dE,dEn,r\[Theta]k,\[Theta]varst,d\[Rho],dcost,baseE,m\[Rho],tvars,assumptions,sansatz,gradclean,gradnoise,noise},*)
(*tvars=Normal@\[Theta]vars;*)
(*assumptions=(If[#[[2]]>0,#[[1]]>0,#[[1]]<0]&)/@tvars;*)
(*sansatz=Simplify[nansatz[[1]],Assumptions->assumptions];*)
(**)
(*(* calculate clean dE/d\[Theta] *)*)
(*ApplyCircuitDerivs[InitZeroState@\[Rho],ansatz/.conf["device"][Aliases],tvars,\[Rho]\[Theta]k];*)
(*ApplyPauliString[\[Rho],conf["hamiltonian"],\[Rho]work];*)
(*dE=Re@CalcDensityInnerProducts[\[Rho]work,\[Rho]\[Theta]k];*)
(*Fkl=Re@CalcDensityInnerProducts[\[Rho]\[Theta]k];*)
(*gradclean=Fit[{Fkl,dE},FitRegularization->{"Tikhonov",conf["\[Alpha]tikhonov"]}];*)
(**)
(*(* calculate clean dE/d\[Theta] *)*)
(*ApplyCircuitDerivs[InitZeroState@\[Rho],sansatz,tvars,\[Rho]\[Theta]k];*)
(*ApplyPauliString[\[Rho],conf["hamiltonian"],\[Rho]work];*)
(*dE=Re@CalcDensityInnerProducts[\[Rho]work,\[Rho]\[Theta]k];*)
(*Fkl=Re@CalcDensityInnerProducts[\[Rho]\[Theta]k];*)
(*gradnoise=Fit[{Fkl,dE},FitRegularization->{"Tikhonov",conf["\[Alpha]tikhonov"]}];*)
(**)
(*(* make the noise normalised with \[Mu]=0 *)*)
(*noise=Normalize[(gradclean-gradnoise)];*)
(*noise-=Mean[noise];*)
(*NG=(gradclean+noise);*)
(**)
(*NG/Max[Norm[NG,2],10^-10]*)
(*]*)
(**)
(**)
(*NaturalGradPerf::usage="Calculate the natural gradient perfectly.";*)
(*NaturalGradPerf[conf_,\[Theta]vars_,ansatz_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_]:=Module[{NG,Fkl,dE,r\[Theta]k,\[Theta]varst,d\[Rho],dcost,baseE,m\[Rho],ansatzal},*)
(*ansatzal=ansatz/.conf["device"][Aliases];*)
(*(* d\[Rho]/Subscript[d, j]\[Theta] *)*)
(*ApplyCircuitDerivs[InitZeroState@\[Rho],ansatzal,Normal@\[Theta]vars,\[Rho]\[Theta]k];*)
(*(*  Use first approximation of QFI: Subscript[F, kl]=Tr[(d\[Rho]/Subscript[d\[Theta], k])(d\[Rho]/Subscript[d\[Theta], l])]*)*)
(*Fkl=Re@CalcDensityInnerProducts[\[Rho]\[Theta]k];*)
(*(*dE/Subscript[d\[Theta], j]*)*)
(*ApplyCircuit[\[Rho],ansatzal/.\[Theta]vars];*)
(*ApplyPauliString[\[Rho],conf["hamiltonian"],\[Rho]work];*)
(*dE=CalcDensityInnerProducts[\[Rho]work,\[Rho]\[Theta]k]//Re;*)
(*(* The natural gradient: F^-1g *)*)
(*NG=LinearSolve[Fkl+conf["\[Alpha]tikhonov"]*IdentityMatrix[Length@Fkl],dE];*)
(*]*)
(**)
(**)
(*NaturalGradCD::usage="Calculate the natural gradient with central difference approaches ";*)
(*NaturalGradCD[conf_,\[Theta]vars_,nansatz_,\[Rho]_,\[Rho]work_]:=Module[{NG,Fkl,dE,r\[Theta]k,\[Theta]varst,\[Theta]varst2,dcost,baseE,d\[Theta],d\[Rho],m\[Rho],hammat},*)
(*hammat=conf["hammat"];d\[Theta]=10^-10;*)
(*d\[Rho]=d\[Rho]cd[conf,nansatz,\[Theta]vars,\[Rho],\[Rho]work];*)
(*ApplyCircuit[InitZeroState@\[Rho],nansatz[[1]]/.\[Theta]vars];*)
(*m\[Rho]=GetQuregMatrix[\[Rho]];*)
(**)
(*dE=Table[Re@Tr[\[Rho]k . hammat . m\[Rho]],{\[Rho]k,d\[Rho]}];*)
(*Fkl=Table[Re@Tr[\[Rho]k . \[Rho]l],{\[Rho]k,d\[Rho]},{\[Rho]l,d\[Rho]}];*)
(*(* The natural gradient: F^-1g *)*)
(*Fit[{Fkl,dE},FitRegularization->{"Tikhonov",conf["\[Alpha]tikhonov"]}];*)
(*NG/Max[Norm[NG,2],d\[Theta]]*)
(*]*)
(**)
(**)
(*d\[Rho]cd::usage="d\[Rho]cd[conf_,nansatz,\[Theta]vars,\[Rho],\[Rho]work]. Calculate the derivative with central difference methode and assign it to \[Rho]\[Theta]k.";*)
(*d\[Rho]cd[conf_,nansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_]:=Module[{\[Theta]varst,\[Theta]varst2,d\[Theta]=10^-10,j=1},*)
(*Table[*)
(*\[Theta]varst=\[Theta]vars;*)
(*\[Theta]varst2=\[Theta]vars;*)
(*\[Theta]varst[k]+=d\[Theta];*)
(*\[Theta]varst2[k]-=d\[Theta];*)
(*ApplyCircuit[InitZeroState@\[Rho],nansatz[[1]]/.\[Theta]varst];*)
(*ApplyCircuit[InitZeroState@\[Rho]work,nansatz[[1]]/.\[Theta]varst2];*)
(*(GetQuregMatrix[\[Rho]]-GetQuregMatrix[\[Rho]work])*0.5/d\[Theta]*)
(*,{k,Keys@\[Theta]vars}]*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Learning*)


(* ::Input:: *)
(*updateCost::usage="updateCost[conf, noisy_ansatz, clean_ansatz, \[Theta]vars, \[Rho], \[Rho]work, \[Rho]\[Theta]k] update the cost function by steepest gradient methode";*)
(*SetAttributes[updateCost,HoldAll]*)
(*updateCost[conf_,nansatz_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_]:=Module[{NG,Ck,tvars,Ecur,\[Theta]varst,baseE,grad,Akl,gradstep,d\[Theta]},*)
(*(* This is executed on a QC, fev calculate how many times QC is used *)*)
(*gradstep=conf["gradstep"];*)
(**)
(*If[Length@\[Theta]vars>0,*)
(*(** NGP, NGSTO, GSTO need ansatz instead of noisy ansatz! **) *)
(*grad=Which[*)
(*conf["grad"]==="NGCD" && Length@\[Theta]vars>1,*)
(*NaturalGradCD[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work]*)
(*,*)
(*conf["grad"]==="GPS" && Length@\[Theta]vars>1,*)
(*GradPS[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work]*)
(*,*)
(*conf["grad"]==="GPSTO" && Length@\[Theta]vars>1,*)
(*GradPStochastic[conf,\[Theta]vars,nansatz,ansatz,\[Rho],\[Rho]work]*)
(*,*)
(*conf["grad"]==="NGAN" && Length@\[Theta]vars>1,*)
(*NaturalGradAnalytic[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work,\[Rho]\[Theta]k]*)
(*,*)
(*conf["grad"]==="NGP" && Length@\[Theta]vars>1,*)
(*NaturalGradPerf[conf,\[Theta]vars,ansatz,\[Rho],\[Rho]work,\[Rho]\[Theta]k]*)
(*,*)
(*conf["grad"]==="NGSTO" && Length@\[Theta]vars>1,*)
(*NaturalGradAnalyticStochastic[conf,\[Theta]vars,nansatz,ansatz,\[Rho],\[Rho]work,\[Rho]\[Theta]k]*)
(*,*)
(*conf["grad"]==="GCDSTO" && Length@\[Theta]vars>1,*)
(*GradCentralDiffStochastic[conf,\[Theta]vars,nansatz,ansatz,\[Rho],\[Rho]work]*)
(*,*)
(*conf["grad"]==="GFDSTO" && Length@\[Theta]vars>1,*)
(*GradFiniteDiffStochastic[conf,\[Theta]vars,nansatz,ansatz,\[Rho],\[Rho]work]*)
(*,*)
(*conf["grad"]==="GCD",*)
(*GradCentralDiff[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work]*)
(*,*)
(*(*** this must stay here: almost the last **)*)
(*conf["grad"]==="GFD" || Length@\[Theta]vars>1,*)
(*GradFiniteDiff[conf,\[Theta]vars,nansatz,\[Rho],\[Rho]work]*)
(*,*)
(*True,*)
(*(*no update*)*)
(*ConstantArray[0,Length@\[Theta]vars]*)
(*];*)
(*(* get the largest possible gradstep; update \[Theta]vars at the same time.*)
(*Make sure to feed it with the noisy version of ansatze.*)
(**)*)
(*{Ecur,gradstep}=dynamicGradStep[conf,nansatz,\[Theta]vars,grad,\[Rho],\[Rho]work];*)
(**)
(*tvars=Normal@\[Theta]vars;*)
(*tvars[[All,2]]-=gradstep*grad;*)
(*\[Theta]vars=Association@tvars;*)
(*,*)
(*{Ecur,gradstep}={costAvg[\[Rho],\[Rho]work,nansatz,conf],0};*)
(*];*)
(*{Ecur,gradstep}*)
(*]*)


(* ::Input:: *)
(*dynamicGradStep::usage="dynamicGradSteps[conf, noisy_ansatz, \[Theta]vars, gradient, \[Rho], \[Rho]work]. Return the minimum energy among different choices of gradient. \[Theta]vars is updated.";*)
(*SetAttributes[dynamicGradStep,HoldAll]*)
(*dynamicGradStep[conf_,nansatz_,\[Theta]vars_,grad_,\[Rho]_,\[Rho]work_]:=Module[{tvars,gradstep,Ebest,Enew,minidx,beststep},*)
(*gradstep=conf["gradstep"] ;*)
(*beststep=gradstep;*)
(*tvars=Normal@\[Theta]vars;*)
(*tvars[[All,2]]-=gradstep*grad;*)
(*Ebest=costAvg[\[Rho],\[Rho]work,nansatz/.\[Theta]vars,conf];*)
(*(* keep the direction, just multiply *)*)
(*If[ NumberQ[conf["gradstepmultiply"]],*)
(*While[True,*)
(*gradstep*=conf["gradstepmultiply"];*)
(*tvars=Normal@\[Theta]vars;*)
(*tvars[[All,2]]-=gradstep*grad;*)
(*Enew=costAvg[\[Rho],\[Rho]work,nansatz/.tvars,conf];*)
(*If[Enew>=Ebest, Break[]];*)
(*Ebest=Enew;*)
(*beststep=gradstep;*)
(*]*)
(*];*)
(*{Ebest,beststep}*)
(*]*)


(* ::Input:: *)
(*RelaxAnsatz::usage="RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep,maxiter:Infinity]. *)
(*Relax ansatz until converge, returns list of costs. Convergence is done by the criteria of slow moving averages.*)
(*";*)
(*SetAttributes[RelaxAnsatz, HoldAll]*)
(*RelaxAnsatz[conf_,fev_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,Ecur_,gradstep_,maxiter_:Infinity]:=Module[*)
(*{Eold,\[Theta]varsold,Elist={},dE,econverge=0,Einit=Ecur,\[Theta]varsinit=\[Theta]vars,failing=0,iter=0,simpansatz,nansatz,Epart,mva,mvalast,Etail,trend1,trend2,x,break=0,Ecurbest,\[Theta]varsbest,\[Epsilon]},*)
(**)
(*(*** some gradient methode require noiseless circuit **)*)
(*nansatz=noisyAnsatz[ansatz,conf];*)
(*simpansatz=DeleteCases[DeleteCases[#,Subscript[Depol, __][0],2],Subscript[Deph, __][0],2]&/@Chop[nansatz];*)
(*simpansatz=DeleteCases[DeleteCases[#,Subscript[Depol, __][0.],2],Subscript[Deph, __][0.],2]&/@simpansatz;*)
(**)
(*Ecur=costAvg[\[Rho],\[Rho]work,simpansatz/.\[Theta]vars,conf];*)
(*{Ecurbest,\[Theta]varsbest}={Ecur,\[Theta]vars};*)
(**)
(*While[*)
(*iter++<=maxiter && Length@\[Theta]vars>0,*)
(*fev++;*)
(*{Ecur,gradstep}=updateCost[conf,simpansatz,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k];*)
(*AppendTo[Elist,{iter,Ecur}];*)
(*(* update the best record *)*)
(*If[Ecur<Ecurbest,{Ecurbest,\[Theta]varsbest}={Ecur,\[Theta]vars}];*)
(*If[Abs[Ecur-conf["groundstate"]]<=conf["\[Epsilon]fin"], Break[]];*)
(**)
(*(*check convergence*)*)
(*If[Length@Elist>2,*)
(*(* Check the last 40%  *)*)
(*Epart=Elist[[-Ceiling[0.4*iter];;]];*)
(*mva=MovingAverage[Epart,IntegerPart[0.9*Length@Epart]];*)
(*(* The 20% tail of data, the moving average *)*)
(*Etail=Elist[[-Max[IntegerPart[Length@Elist*0.2],2];;]];*)
(*mvalast=MovingAverage[Etail,IntegerPart[0.8*Length@Etail]];*)
(*(* check both trends *)*)
(*trend1=Chop@Coefficient[Fit[mva,{1,x},x],x];*)
(*trend2=Chop@Coefficient[Fit[mvalast,{1,x},x],x];*)
(**)
(*\[Epsilon]=10^-3;*)
(*If[trend1>=-\[Epsilon] && trend2>=-\[Epsilon],*)
(*break++;*)
(*If[break>1,Break[]],*)
(*break=0;*)
(*]*)
(*];*)
(*];*)
(*{Ecur,\[Theta]vars}={Ecurbest,\[Theta]varsbest};*)
(*Elist[[All,2]]*)
(*]*)


(* ::Subsection::Closed:: *)
(*Cost function and noisy-decorated  gates*)


(* ::Input:: *)
(*getQubits::usage="Return qubits as index of gate. The ones contains \!\(\*SubscriptBox[\(\[Theta]\), \(j\)]\) is excluded.";*)
(*getQubits[gate_]:=Cases[gate,Subscript[base_,subscript__]/;!(base===\[Theta]):>subscript,{0,Infinity},Heads->True]*)


(* ::Input:: *)
(*replaceQubits::usage="Repalce the index of gates. The ones contains \!\(\*SubscriptBox[\(\[Theta]\), \(j\)]\) is excluded.";*)
(*replaceQubits[gate_,nq_,indices__]:=Module[{i,qubits,template,\[Theta]x},*)
(*For[i=0,i<=Length@conf["gateset"][nq],i++,*)
(*qubits=getQubits[gate];*)
(*template=conf["gateset"][2][[i]];*)
(*If[MatchQ[gate/.Subscript[\[Theta], _]:>\[Theta],template@@qubits],*)
(*\[Theta]x=Cases[gate,Subscript[\[Theta],subscript_]:>Subscript[\[Theta], subscript],{0,Infinity},Heads->True];*)
(*Break[]*)
(*]*)
(*];*)
(*template[indices]/.\[Theta]:>\[Theta]x*)
(*]*)


(* ::Input:: *)
(*ClearAll[compileTwoQubitGates]*)
(*compileTwoQubitGates::usage="compileTwoQubitGates[ansatz,conf]. Compile the two-qubit gates into having the proper connectivity by a chain of swaps. This function is invoked only when setting fullconn=True";*)
(*compileTwoQubitGates[ansatz_,conf_]:=Module[{conn,qubits,gates,path,pathpair,connswap,gateev},*)
(*If[*)
(*ListQ[conf["fullconn"]]&&Length@conf["fullconn"]>0&&Length@ansatz>0,*)
(*Table[*)
(*qubits=getQubits[gate];*)
(*If[*)
(*(* Two qubit gate*)*)
(*Length@qubits==2 &&Or@@(MatchQ[gate/.Subscript[\[Theta], _]:>\[Theta],#@@qubits]&/@conf["gateset"][2])*)
(*,*)
(*(*get the true connectivity*)*)
(*conn=If[Head@conf["connectivity"]===Function,conf["connectivity"]@gate,conf["connectivity"]];*)
(*If[*)
(*MemberQ[EdgeList@conn, Alternatives@{DirectedEdge@@qubits,UndirectedEdge@@qubits}],*)
(*gate*)
(*,*)
(*(*get the swap connectivity*)*)
(*connswap=If[Head@conf["connectivity"]===Function,conf["connectivity"][conf["swap"]@@qubits],conf["connectivity"]];*)
(*path=FindShortestPath[connswap,Sequence@@qubits];*)
(*pathpair=ReplaceList[path,{p___,a_,b_,q___}:>{a,b}];*)
(*gates={replaceQubits[gate,2,Sequence@@pathpair[[1]]]};*)
(**)
(*Table[AppendTo[gates,conf["swap"]@@pair],{pair,pathpair[[2;;]]}];*)
(*Sequence@@gates*)
(*]*)
(*(* Others *)*)
(*,*)
(*gate*)
(*]*)
(*,{gate,ansatz}]*)
(*,*)
(*ansatz*)
(*]*)
(*]*)


(* ::Input:: *)
(*(* Expected value of a Hamiltonian averaged to the training set *)*)
(*SetAttributes[costAvg,HoldAll]*)
(*costAvg::usage="costAvg[\[Rho], \[Rho]work, noisy_ansatz, conf]. Return the average of training set cost function with zero noise interpolation.";*)
(*costAvg[\[Rho]_,\[Rho]work_,nansatz_,conf_]:=Module[{x},*)
(*If[Length@nansatz===2,*)
(*Fit[{*)
(*{1,costFunction[\[Rho],\[Rho]work,nansatz[[1]],conf]},*)
(*{2,costFunction[\[Rho],\[Rho]work,nansatz[[2]],conf]}},*)
(*{1,x},*)
(*x*)
(*]/.x->0.*)
(*,*)
(*costFunction[\[Rho],\[Rho]work,Flatten@nansatz,conf]*)
(*]*)
(*];*)
(**)
(**)
(**)
(*costFunction::usage="costFunction[\[Rho],\[Rho]work,nansatz,conf]. Return the cost function, averaged if there are two devices -- for error mitigation purposes";*)
(*costFunction[\[Rho]_,\[Rho]work_,nansatz_,conf_]:=Module[{},*)
(*ApplyCircuit[InitZeroState@\[Rho],nansatz];*)
(*CalcExpecPauliString[\[Rho],conf["hamiltonian"],\[Rho]work]*)
(*]*)
(**)
(**)
(*noisyAnsatz::usage="noisyAnsatz[ansatz, conf]. Return the noise-decorated gates.";*)
(*SetAttributes[noisyAnsatz,HoldAll]*)
(*noisyAnsatz[ansatz_,conf_, OptionsPattern[]]:=Module[{dev1,dev2,ccirc1, ccirc2,fullcirc},*)
(*dev1=conf["device"]; (*copy the virtual devices*)*)
(*dev2=conf["device2"];*)
(**)
(*If[OptionValue[noisyAnsatz, Noisy] == False,*)
(*{Flatten[Join[conf["initcirc"],ansatz]/.dev1[Aliases]]}*)
(*,*)
(**)
(*fullcirc=compileTwoQubitGates[Join[conf["initcirc"],ansatz],conf]/.CustomGatesDefinitions;*)
(**)
(*ccirc1=Which[*)
(*dev1[DeviceType]==="SiliconDelft",*)
(*CircSiliconDelft[fullcirc,dev1,Parallel->conf["parallel"]]*)
(*,*)
(*dev1[DeviceType]==="TrappedIonOxofrd",*)
(*CircTrappedIons[fullcirc,dev1,MapQubits->False,Parallel->conf["parallel"]]*)
(*,*)
(*True*)
(*,*)
(*fullcirc*)
(*];*)
(*If[AssociationQ[dev2],*)
(*ccirc2=Which[*)
(*dev2[DeviceType]==="SiliconDelft",*)
(*CircSiliconDelft[fullcirc,dev2,Parallel->conf["parallel"]]*)
(*,*)
(*dev1[DeviceType]==="TrappedIonOxofrd",*)
(*CircTrappedIons[fullcirc,dev2,MapQubits->False,Parallel->conf["parallel"]]*)
(*,*)
(*True*)
(*,*)
(*fullcirc*)
(*];*)
(*];*)
(**)
(*If[\[Not]AssociationQ[dev2],*)
(*{Join[ExtractCircuit@InsertCircuitNoise[ccirc1,dev1,ReplaceAliases->True],conf["virtualmeas"]]}*)
(*,*)
(*{*)
(*Join[ExtractCircuit@InsertCircuitNoise[ccirc1,dev1,ReplaceAliases->True],conf["virtualmeas"]],*)
(*Join[ExtractCircuit@InsertCircuitNoise[ccirc2,dev2,ReplaceAliases->True],conf["virtualmeas"]]*)
(*}*)
(*]*)
(**)
(*]*)
(**)
(*]*)


(* ::Subsection:: *)
(*Pruning*)


(* ::Subsubsection::Closed:: *)
(*Total pruning*)


(* ::Input:: *)
(*PruneGates::usage="PruneGates[conf, fev, Ecur, gradstep, ansatz, \[Theta]vars, \[Rho], \[Rho]work, \[Rho]\[Theta]k, maxcost, fullbf:False]. *)
(*Prune the circuit using the 4 methods";*)
(*SetAttributes[PruneGates,HoldAll]*)
(*PruneGates[conf_,fev_,Ecur_,gradstep_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,maxcost_,fullbf_,status_]:=Module[{slen,dl=1,elimmerge=0,elimmetov=0,elimbfsmall=0,elimbf=0,Einit=Ecur,total,base},*)
(**)
(*base="Pruning with maxcost "<>ToString[maxcost,FortranForm]<>". ";*)
(**)
(*total:=" ;merged:"<>ToString[elimmerge]<>", metric:"<>ToString[elimmetov]<>", small\[Theta]:"<>ToString[elimbfsmall]<>", bffirst:"<>ToString[elimbf];*)
(**)
(*elimmerge+=MergeGates[ansatz,\[Theta]vars];*)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]vars,\[Rho]\[Theta]k];*)
(**)
(*While[dl>0,*)
(*slen=Length@ansatz ;*)
(**)
(*If[Length@\[Theta]vars>1,*)
(*AdjustAngles[\[Theta]vars];*)
(*status=base<>" Brute-force small \[Theta]"<>total;*)
(*elimbfsmall+=BruteForceSmall\[Theta][conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost,fullbf];*)
(*status=base<>" Merge gates"<>total;*)
(*elimmerge+=MergeGates[ansatz,\[Theta]vars];*)
(*];*)
(**)
(**)
(**)
(*If[Length@\[Theta]vars>1,*)
(*AdjustAngles[\[Theta]vars];*)
(*status=base<>" Quick brute-force "<>total;*)
(*elimbf+=DeleteGateBF[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost,fullbf];*)
(*status=base<>" Merge gates "<>total;*)
(*elimmerge+=MergeGates[ansatz,\[Theta]vars];*)
(*];*)
(**)
(*(* only avail on nat grad with FD methode*)*)
(*If[MemberQ[{"NGAN","NGP"},conf["grad"]] && Length@\[Theta]vars>1,*)
(*AdjustAngles[\[Theta]vars];*)
(*status=base<>" Delete gates by metric "<>total;*)
(*elimmetov+=DeleteGatesByMetric[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost];*)
(*status=base<>" Merge gates"<>total;*)
(*elimmerge+=MergeGates[ansatz,\[Theta]vars];*)
(*];*)
(**)
(**)
(**)
(*dl=slen-Length@ansatz;*)
(*];*)
(**)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]vars,\[Rho]\[Theta]k];*)
(*If[Ecur>maxcost,*)
(*Print["pruning exceeds the maxcost: ",N@maxcost,"; cost=",Ecur]];*)
(**)
(*{elimmerge,elimbfsmall,elimmetov, elimbf}*)
(**)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Simple merge*)


(* ::Input:: *)
(*(* Merging gates, only tested for single rotation and controlled-rotation so far *)*)
(*MergeGates::usage="MergeGates[ansatz_,\[Theta]vars_] merge obvious gate in ansatz. It is not optimized for non-parametric gates. Works well with single rotation and controlled-rotations";*)
(*SetAttributes[MergeGates,HoldAll]*)
(*MergeGates[ansatz_,\[Theta]vars_]:=Module[{ancol,slen,,\[Theta]merge={},deleted=0},*)
(*While[True,*)
(*slen=Length@ansatz;*)
(*ancol=GetCircuitColumns[ansatz];*)
(*(* simplify non-parametric gates *)*)
(**)
(*If[Length@\[Theta]vars<Length@ansatz,*)
(*ancol=ancol//.{*)
(*{a___,{b___,Subscript[H, j_],c___},{d___,Subscript[H, j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[X, j_],c___},{d___,Subscript[X, j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[Y, j_],c___},{d___,Subscript[Y, j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[Z, j_],c___},{d___,Subscript[Z, j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Z, j_]],c___},{d___,Subscript[C, i_][Subscript[Z, j_]],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Z, j_]],c___},{d___,Subscript[C, j_][Subscript[Z, i_]],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[X, j_]],c___},{d___,Subscript[C, i_][Subscript[X, j_]],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Y, j_]],c___},{d___,Subscript[C, i_][Subscript[Y, j_]],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[SWAP, i_,j_],c___},{d___,Subscript[SWAP, i_,j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[SWAP, i_,j_],c___},{d___,Subscript[SWAP, j_,i_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[ZZ, i_,j_],c___},{d___,Subscript[ZZ, i_,j_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[ZZ, i_,j_],c___},{d___,Subscript[ZZ, j_,i_],e___},f___}:>{a,{b,c},{d,e},f},*)
(*{a___,{b___,Subscript[ZX, i_,j_],c___},{d___,Subscript[ZX, i_,j_],e___},f___}:>{a,{b,c},{d,e},f}*)
(*};*)
(*];*)
(**)
(*(* simplify parametric gates *)*)
(*ancol=ancol//.{*)
(*{a___,{b___,Subscript[Rx, j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[Rx, j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[Rx, j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[Ry, j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[Ry, j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[Ry, j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[Rz, j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[Rz, j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[Rz, j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Rz, j_][Subscript[\[Theta], k_]]],c___},{d___,Subscript[C, i_][Subscript[Rz, j_][Subscript[\[Theta], l_]]],e___},f___}:>{a,{b,Subscript[C, i][Subscript[Rz, j][Subscript[\[Theta], k]]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Rx, j_][Subscript[\[Theta], k_]]],c___},{d___,Subscript[C, i_][Subscript[Rx, j_][Subscript[\[Theta], l_]]],e___},f___}:>{a,{b,Subscript[C, i][Subscript[Rx, j][Subscript[\[Theta], k]]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Ry, j_][Subscript[\[Theta], k_]]],c___},{d___,Subscript[C, i_][Subscript[Ry, j_][Subscript[\[Theta], l_]]],e___},f___}:>{a,{b,Subscript[C, i][Subscript[Ry, j][Subscript[\[Theta], k]]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Ph, j_][Subscript[\[Theta], k_]]],c___},{d___,Subscript[C, i_][Subscript[Ph, j_][Subscript[\[Theta], l_]]],e___},f___}:>{a,{b,Subscript[C, i][Subscript[Ph, j][Subscript[\[Theta], k]]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[C, i_][Subscript[Ph, j_][Subscript[\[Theta], k_]]],c___},{d___,Subscript[C, j_][Subscript[Ph, i_][Subscript[\[Theta], l_]]],e___},f___}:>{a,{b,Subscript[C, i][Subscript[Ph, j][Subscript[\[Theta], k]]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[ZX, i_,j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[ZX, i_,j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[ZX, i,j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[ZZ, i_,j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[ZZ, i_,j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[ZZ, i,j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[ZZ, i_,j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[ZZ, j_,i_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[ZZ, i,j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[PSW, i_,j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[PSW, i_,j_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[PSW, i,j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f},*)
(*{a___,{b___,Subscript[PSW, i_,j_][Subscript[\[Theta], k_]],c___},{d___,Subscript[PSW, j_,i_][Subscript[\[Theta], l_]],e___},f___}:>{a,{b,Subscript[PSW, i,j][Subscript[\[Theta], k]],c},{d,{Subscript[\[Theta], k],Subscript[\[Theta], l]},e},f}*)
(*};*)
(*ansatz=Flatten[ancol,1];*)
(*\[Theta]merge=Select[ansatz,ListQ];*)
(*ansatz=DeleteCases[ansatz,_List];*)
(*(* merge the parameters *)*)
(*deleted+=Length@\[Theta]merge;*)
(*If[Length@\[Theta]merge>0,*)
(*Table[*)
(*\[Theta]vars[t[[1]]]+=\[Theta]vars[t[[2]]];*)
(*\[Theta]vars=KeyDrop[\[Theta]vars,t[[2]]]*)
(*,{t,\[Theta]merge}]*)
(*];*)
(*If[Length@ansatz===slen,Break[]];*)
(*];*)
(*deleted*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Small \[Theta]*)


(* ::Input:: *)
(*BruteForceSmall\[Theta]::usage="BruteForceSmall\[Theta][conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost,fullbf]*)
(* Burte-focefully try to eliminate small gates. Gates are sorted by the angles, and eliminate it one by one until it fails failtrial times, unless*)
(*fullbf=True. If fullbf=True, SWAPs will be deleted as well.";*)
(*SetAttributes[BruteForceSmall\[Theta],HoldAll]*)
(*BruteForceSmall\[Theta][conf_,fev_,Ecur_,gradstep_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,maxcost_,fullbf_:False]:=Module[*)
(*{ansatztmp,Etmp=Ecur,Akl=0,\[Theta]varstmp=\[Theta]vars,\[Theta]varsinit=\[Theta]vars,Einit=Ecur,del\[Theta]={},k,j,keysort\[Theta]vars,nansatztmp,ansatzold,Eold,\[Theta]varsold,\[Theta]cand,converge=0,deleted={},fail=0,fail\[Theta]={},maxfail=IntegerPart[0.2*Length@\[Theta]vars]},*)
(*(* Brutefocelly try to delete each gate from the smallest one *)*)
(*keysort\[Theta]vars=Keys[Sort[Min[{Abs[#-4\[Pi]],Abs[#-2\[Pi]],Abs[#],Abs[#+2\[Pi]],Abs[#+4\[Pi]]}]&/@\[Theta]vars]];*)
(**)
(*For[k=1, k<=Length@keysort\[Theta]vars, k++,*)
(*\[Theta]cand=keysort\[Theta]vars[[k]];*)
(**)
(*\[Theta]varstmp=KeyDrop[\[Theta]vars,{\[Theta]cand}]; *)
(*ansatztmp=DeleteCases[ansatz,_?(ContainsAny[Level[#,-1],{\[Theta]cand}]&)];*)
(**)
(*If[Length@\[Theta]varstmp<2,Break[]];*)
(**)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]varstmp,\[Rho]\[Theta]k];*)
(*RelaxAnsatz[conf, fev, ansatztmp, \[Theta]varstmp, \[Rho], \[Rho]work, \[Rho]\[Theta]k, Etmp, gradstep, conf["maxbfiter"]];*)
(**)
(*If[Etmp<= maxcost,*)
(*(* works out, apply changes *)*)
(*{ansatz,Ecur,\[Theta]vars}={ansatztmp,Etmp,\[Theta]varstmp};*)
(*AppendTo[del\[Theta],\[Theta]cand]*)
(*,*)
(*fail+=1;*)
(*If[(fail>=maxfail) && \[Not]fullbf ,Break[]]*)
(*];*)
(*];*)
(**)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]vars,\[Rho]\[Theta]k];*)
(*Length@del\[Theta]*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Metric tensor*)


(* ::Input:: *)
(*DeleteGatesByMetric::usage="DeleteGatesByMetric[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost]*)
(*delete gates by similarity of rows in metric \!\(\*SubscriptBox[\(A\), \(kl\)]\)";*)
(*SetAttributes[DeleteGatesByMetric,HoldAll]*)
(*DeleteGatesByMetric[conf_,fev_,Ecur_,gradstep_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,maxcost_]:=Module[*)
(*{didx={},\[Theta]del,elim\[Theta],ndeleted=0,j,\[Theta]varskeys,Eold,\[Theta]varsold,dE,econverge=0,Etmp=Ecur,\[Theta]varstmp=\[Theta]vars,ansatztmp=ansatz,simidx={},sim\[Theta],nt,d\[Rho],m\[Rho],d\[Theta]=10^-10,\[Theta]varst,nansatz,Akl,nansatztmp,tvars,assumptions,sansatz},*)
(*If[MemberQ[{"NGP","GSTO","GPSTO","NGSTO"},conf["grad"]],*)
(*nansatz=noisyAnsatz[ansatz,conf];*)
(*tvars=Normal@\[Theta]vars;*)
(*assumptions=(If[#[[2]]>0,#[[1]]>0,#[[1]]<0]&)/@tvars;*)
(*sansatz=Simplify[nansatz[[1]],Assumptions->assumptions],*)
(*sansatz=ansatz/.conf["device"][Aliases]*)
(*];*)
(*(*gather all Akl*)*)
(*nt=Length@conf["\[Rho]init"];*)
(*Akl=Re@CalcMetricTensor[\[Rho],sansatz,Normal@\[Theta]vars];*)
(**)
(*(* indices of redundant rows *)*)
(*Table[*)
(*For[j=1,j<i,j++,*)
(*If[*)
(*Norm[Akl[[i]]]<=conf["metignore"],*)
(*(*too flat *)*)
(*AppendTo[didx,i];*)
(*Break[]*)
(*,*)
(*(*find other similar ones by projecting *)*)
(*If[*)
(*Catch[*)
(*Quiet[Check[VectorAngle[Akl[[i]],Akl[[j]]],0,ArcTan::indet]]<=conf["metignore"]*)
(*],*)
(*AppendTo[didx,i];*)
(*AppendTo[simidx,{i,j}];*)
(*(* found the similar one *)*)
(*Break[]*)
(*]*)
(*]*)
(**)
(*]*)
(*,{i,Length@\[Theta]vars}];*)
(**)
(*\[Theta]varskeys=Keys@\[Theta]vars;*)
(*elim\[Theta]=Table[\[Theta]varskeys[[j]],{j,didx}];*)
(*sim\[Theta]=Table[{\[Theta]varskeys[[j[[1]]]],\[Theta]varskeys[[j[[2]]]]},{j,simidx}];*)
(**)
(*If[(Length@elim\[Theta]>0),*)
(*(*update assoc \[Theta]vars*)*)
(*\[Theta]varstmp=KeyDrop[\[Theta]vars,elim\[Theta]];*)
(*ansatztmp=DeleteCases[ansatz,_?(ContainsAny[Level[#,-1],elim\[Theta]]&)];*)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]varstmp,\[Rho]\[Theta]k];*)
(**)
(*(* Relax the result *)*)
(*RelaxAnsatz[conf, fev, ansatztmp, \[Theta]varstmp, \[Rho], \[Rho]work, \[Rho]\[Theta]k, Etmp, gradstep, conf["maxpruneiter"]];*)
(**)
(*If[Etmp<=maxcost,*)
(*ndeleted+=Length@elim\[Theta];*)
(*{Ecur,ansatz,\[Theta]vars}={Etmp,ansatztmp,\[Theta]varstmp};*)
(*];*)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]vars,\[Rho]\[Theta]k];*)
(*];*)
(**)
(*ndeleted*)
(*]*)


(* ::Subsubsection::Closed:: *)
(*Quick brute force*)


(* ::Input:: *)
(*DeleteGateBF::usage="DeleteGateBF[conf,fev,Ecur,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost]. *)
(*Brute force deletion one by one.";*)
(*SetAttributes[DeleteGateBF,HoldAll]*)
(*DeleteGateBF[conf_,fev_,Ecur_,gradstep_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,maxcost_,fullbf_:True]:=Module[*)
(*{ansatztmp,Etmp=Ecur,\[Theta]varstmp=\[Theta]vars,\[Theta]varsinit=\[Theta]vars,len=Length@ansatz,k,idxdel=1,\[Theta]del,j,Eold,ansatzold,\[Theta]varsold,del=0,maxiter=Max[IntegerPart[conf["maxpruneiter"]/Length@ansatz],5],nansatztmp},*)
(*(* Brutefocelly try to delete each gate from the smallest one *)*)
(*For[k=1, k<=len, k++,*)
(*ansatztmp=Delete[ansatz,idxdel];*)
(*\[Theta]del=Cases[Level[ansatz[[idxdel]],-1],Subscript[\[Theta], _]];*)
(*\[Theta]varstmp=KeyDrop[\[Theta]vars,\[Theta]del];*)
(**)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]varstmp,\[Rho]\[Theta]k];*)
(*RelaxAnsatz[conf, fev, ansatztmp, \[Theta]varstmp, \[Rho], \[Rho]work, \[Rho]\[Theta]k, Etmp, gradstep, conf["maxbfiter"]];*)
(*If[Etmp<= maxcost,*)
(*(* works out, apply changes *)*)
(*{ansatz,Ecur,\[Theta]vars}={ansatztmp,Etmp,\[Theta]varstmp};*)
(*del++;*)
(*,*)
(*idxdel++*)
(*];*)
(*];*)
(*AdjustQuregs\[Rho]\[Theta]k[conf["nqubit"],\[Theta]vars,\[Rho]\[Theta]k];*)
(**)
(*del*)
(*]*)
(**)
(**)
(*DeleteGateBFLayer::usage="DeleteGateBF[conf,fev,Ecur,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost]. *)
(*Brute force deletion, layer by layer. The first layer sometimes are useless since most of the time states are started from zeros.";*)
(*SetAttributes[DeleteGateBFLayer,HoldAll]*)
(*DeleteGateBFLayer[conf_,fev_,Ecur_,gradstep_,ansatz_,\[Theta]vars_,\[Rho]_,\[Rho]work_,\[Rho]\[Theta]k_,maxcost_,fullbf_:True]:=Module[{deleted=0,\[Theta]del,idx=1,\[Theta]varstmp=\[Theta]vars,ansatztmp=ansatz,j,Eold,\[Theta]varsold,Etmp=Ecur,Einit=Ecur,maxlayer=0,old\[Theta]vars,oldE,nansatztmp,maxiter=5,k,alen=Length@ansatz},*)
(*For[k=1,k<= alen,k++,*)
(*(* record before removing gate q *)*)
(*old\[Theta]vars=\[Theta]varstmp;oldE=Etmp;*)
(*(* update *)*)
(*\[Theta]del=Cases[Level[ansatz[[idx]],-1],Subscript[\[Theta], _]];*)
(**)
(*(* keep the permutation operators *)
(*If[\[Not]fullbf && MatchQ[Cases[ansatz,_?(ContainsAny[Level[#,-1],{\[Theta]del}]&)]\[LeftDoubleBracket]1\[RightDoubleBracket],swapGate[conf["device"][DeviceType]][_,_]/.\[Theta]:>\[Theta]del],*)
(*Continue[]];*)*)
(*ansatztmp=Delete[ansatz,idx];*)
(*\[Theta]varstmp=KeyDrop[\[Theta]varstmp,\[Theta]del];*)
(*RelaxAnsatz[conf, fev, ansatztmp, \[Theta]varstmp, \[Rho], \[Rho]work, \[Rho]\[Theta]k, Etmp, gradstep, conf["maxbfiter"]];*)
(**)
(*(* delete/keep gate q *)*)
(*If[Etmp<=maxcost,*)
(*deleted++;*)
(*{ansatz,\[Theta]vars,Ecur}={ansatztmp,\[Theta]varstmp,Etmp};*)
(*,*)
(*(* reject *)*)
(*{Etmp,\[Theta]varstmp}={oldE,old\[Theta]vars};*)
(*idx++;*)
(*];*)
(**)
(*];*)
(**)
(*deleted*)
(*]*)


(* ::Subsection:: *)
(*The VQE*)


(* ::Subsubsection::Closed:: *)
(*(hyper)-parameters adjustment*)


(* ::Input:: *)
(*(* Adjust quantum register \[Psi]\[Theta]k wrt \[Theta]vars *)*)
(*AdjustQuregs\[Rho]\[Theta]k::usage="AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k] adjust allocation of \[Rho]\[Theta]k according to \[Theta]vars";*)
(*SetAttributes[AdjustQuregs\[Rho]\[Theta]k,HoldRest]*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit_,\[Theta]vars_,\[Rho]\[Theta]k_]:=Module[{lendiff},*)
(*lendiff=Length@\[Rho]\[Theta]k-Length@\[Theta]vars;*)
(*Which[lendiff>0,*)
(*(* release some quantum memories *)*)
(*Table[DestroyQureg[\[Rho]\[Theta]k[[-q]]],{q,lendiff}];*)
(*\[Rho]\[Theta]k=\[Rho]\[Theta]k[[;;-1-lendiff]]*)
(*,*)
(*lendiff < 0,*)
(*(* add some quantum memories otherwise *)*)
(*\[Rho]\[Theta]k=Join[\[Rho]\[Theta]k,CreateDensityQuregs[nqubit,Abs[lendiff]]];*)
(*];*)
(*]*)


(* ::Input:: *)
(*AdjustSpeed::usage="AdjustSpeed[conf,defconf,slowdown,ncycle]. Adjust some hyperparameters.";*)
(*SetAttributes[AdjustSpeed,HoldAll];*)
(*AdjustSpeed[conf_,defconf_,slowdown_,ncycle_]:=Module[{stat},*)
(*(* first, try to speedup: more gates, more disturbed system *)*)
(*If[conf["gatespercycle"]>=4defconf["gatespercycle"],*)
(*slowdown= False;*)
(*(*reset first before speedingup *)*)
(*Table[conf[ToString[key]]=defconf[key],{key,Keys@conf}];*)
(*];*)
(**)
(*If[slowdown,*)
(*(* the computation is going slower *)*)
(*conf["ngatesinit"]=Min[Ceiling[conf["ngatesinit"]*1.2],4 defconf["ngatesinit"]];*)
(*conf["greediness"]++;*)
(*conf["greed\[Theta]"]++;*)
(*conf["g\[Theta]iter"]++;*)
(*stat="Slowing down";*)
(*,*)
(*(* the computation is going faster *)*)
(*conf["ngatesinit"]=Max[Ceiling[conf["ngatesinit"]*0.8],conf["nqubit"]];*)
(*conf["\[Alpha]tikhonov"]=Min[conf["\[Alpha]tikhonov"]*1.2,1.0];*)
(*conf["gradstep"]=Max[conf["gradstep"]*0.8,10^-3];*)
(*conf["greediness"]+=1;*)
(*stat="Speeding up";*)
(*];*)
(*stat*)
(*];*)


(* ::Input:: *)
(*AdjustAngles::usage="AdjustAngles[\[Theta]vars]. Adjust \[Theta]vars so that angles within the range [-\[Pi],\[Pi]]. Note that this process will alter the cost, since different duration alters the passive noise.";*)
(*SetAttributes[AdjustAngles,HoldFirst]*)
(*AdjustAngles[\[Theta]vars_]:=Module[{newangle},*)
(*Table[*)
(*newangle=Mod[\[Theta]vars[k],2\[Pi]];*)
(*If[newangle>\[Pi],newangle-=2\[Pi]];*)
(*\[Theta]vars[k]=newangle*)
(*,{k,Keys@\[Theta]vars}]]*)


(* ::Input:: *)
(*Wrap::usage="Wrap[list,anzatz,angle,enerhy,sidx,hash___]. Wrap data into a list of association.";*)
(*SetAttributes[Wrap,HoldFirst];*)
(*Wrap[list_,anz_,ang_,en_,sidx_,hash___]:=Module[{},*)
(*AppendTo[list[["ansatz"]],anz];*)
(*AppendTo[list[["\[Theta]vars"]],ang];*)
(*AppendTo[list[["E"]],en];*)
(*AppendTo[list[["idx"]],sidx];*)
(*If[Length@{hash}>0,AppendTo[list[["hash"]],hash]];*)
(*];*)


(* ::Input:: *)
(*plotmat[matrix_]:=MatrixPlot[matrix,{PlotTheme->"Detailed",PlotLabel->"correlation",ImageSize->440,FrameStyle->Directive[Black,Medium],FrameTicks->All,ColorFunction->cscheme,ColorFunctionScaling->False,PlotLegends->Placed[BarLegend[{cscheme[#]&,{-1,1}}],Bottom]}]*)
(*cscheme=(Blend[{RGBColor[0.02,1,1],RGBColor[0,0.48,1],RGBColor[0,0,0.73],Black,RGBColor[0.6,0.22,0],RGBColor[1,0.55,0],White},Rescale[#1,{-1,1}]]&);*)


(* ::Subsubsection:: *)
(*Main function*)


(* ::Input:: *)
(*SetAttributes[VQE,HoldAll]*)


(* ::Input:: *)
(*Noisy::usage="Run VQD in noisy setting";*)


(* ::Input:: *)
(*Options[VQE]={Noisy->True};*)
(*Options[noisyAnsatz] = {Noisy -> True};*)


(* ::Input:: *)
(*VQE[hamiltonian_, device_, ansatzinit_, OptionsPattern[]]:=Module[*)
(*{\[Rho],\[Rho]work,\[Theta]vars,\[Rho]\[Theta]k={},idx=0,Ecur,\[Theta]varsl,ge\[Theta],\[Theta]varst,nqubit,gE,gradstep,g\[Theta]iter,fev=0,conf,ansatz,*)
(*Eold,\[Theta]varsold,dE,econverge=0,Einit,\[Theta]varsinit,failing=0,iter=0,simpansatz,nansatz,Epart,mva,mvalast,Etail,trend1,trend2,x,break=0,Ecurbest,\[Theta]varsbest,\[Epsilon],Elist={}}*)
(*,*)
(* conf = DefaultConfig[device, hamiltonian];*)
(*conf["ansatz"]=ansatzinit;*)
(*nqubit=conf["nqubit"];*)
(*g\[Theta]iter=conf["g\[Theta]iter"];*)
(*(* Initializations *)*)
(*{\[Rho],\[Rho]work}=CreateDensityQuregs[nqubit,2];*)
(*ansatz=ansatzinit/.\[Theta]:>Subscript[\[Theta], idx++];*)
(*\[Theta]vars=<|Table[Subscript[\[Theta], i]->RandomReal[{-conf["\[Theta]initrange"],conf["\[Theta]initrange"]}],{i,0,idx-1}]|>;*)
(*Options[noisyAnsatz] = {Noisy -> OptionValue[VQE, Noisy]};*)
(**)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*Ecur=costAvg[\[Rho],\[Rho]work,noisyAnsatz[ansatz,conf]/.\[Theta]vars,conf];*)
(**)
(*Einit=Ecur;*)
(*\[Theta]varsinit=\[Theta]vars;*)
(*Monitor[*)
(*Ecur=costAvg[\[Rho],\[Rho]work,noisyAnsatz[ansatz,conf]/.\[Theta]vars,conf];*)
(*AppendTo[Elist,Ecur];*)
(**)
(*(*** some gradient methode require noiseless circuit **)*)
(*nansatz=noisyAnsatz[ansatz,conf];*)
(*simpansatz=DeleteCases[DeleteCases[#,Subscript[Depol, __][0],2],Subscript[Deph, __][0],2]&/@Chop[nansatz];*)
(*simpansatz=DeleteCases[DeleteCases[#,Subscript[Depol, __][0.],2],Subscript[Deph, __][0.],2]&/@simpansatz;*)
(**)
(*Ecur=costAvg[\[Rho],\[Rho]work,simpansatz/.\[Theta]vars,conf];*)
(*{Ecurbest,\[Theta]varsbest}={Ecur,\[Theta]vars};*)
(**)
(*While[*)
(*iter++<=Infinity && Length@\[Theta]vars>0,*)
(*fev++;*)
(*{Ecur,gradstep}=updateCost[conf,simpansatz,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k];*)
(*AppendTo[Elist,Ecur];*)
(**)
(*(* update the best record *)*)
(*If[Ecur<Ecurbest,{Ecurbest,\[Theta]varsbest}={Ecur,\[Theta]vars}];*)
(*If[Abs[Ecur-conf["groundstate"]]<=conf["\[Epsilon]fin"], Break[]];*)
(**)
(*(*check convergence*)*)
(*If[Length@Elist>5,*)
(*(* Check the last 40%  *)*)
(*Epart=Elist[[-Ceiling[0.4*iter];;]];*)
(*mva=MovingAverage[Epart,IntegerPart[0.9*Length@Epart]];*)
(*(* The 20% tail of data, the moving average *)*)
(*Etail=Elist[[-Max[IntegerPart[Length@Elist*0.3],2];;]];*)
(*mvalast=MovingAverage[Etail,IntegerPart[0.8*Length@Etail]];*)
(*(* check both trends *)*)
(*trend1=Chop@Coefficient[Fit[mva,{1,x},x],x];*)
(*trend2=Chop@Coefficient[Fit[mvalast,{1,x},x],x];*)
(**)
(*\[Epsilon]=10^-5;*)
(*If[trend1>=-\[Epsilon] && trend2>=-\[Epsilon],*)
(*break++;*)
(*Table[\[Theta]vars[t]+=RandomReal[{-0.2,0.2}],{t,Keys@\[Theta]vars}];*)
(*{Ecur,gradstep}=updateCost[conf,simpansatz,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k];*)
(*AppendTo[Elist,Ecur];*)
(**)
(*If[break>3,Break[]],*)
(*break=0;*)
(*]*)
(*];*)
(*{Ecur,\[Theta]vars}={Ecurbest,\[Theta]varsbest};*)
(*];*)
(*,*)
(*ListPlot[Elist-conf["groundstate"],Frame->True,FrameStyle->{Black,Thick},PlotRange->{{0,Max[100,Length@Elist]},{0,1}},ImageSize->500,FrameLabel->{"Iteration","\[Epsilon]"},BaseStyle->"Subtitle"]*)
(*];*)
(**)
(*Table[DestroyQureg[q],{q,Flatten@{\[Rho],\[Rho]work,\[Rho]\[Theta]k}}];*)
(**)
(*Print@ListPlot[Elist-conf["groundstate"],Frame->True,FrameStyle->{Black,Thick},PlotRange->{{0,Max[100,Length@Elist]},{0,1}},ImageSize->500,FrameLabel->{"Iteration","\[Epsilon]"},BaseStyle->"Subtitle"];*)
(*Print["\!\(\*SubscriptBox[\(\[Epsilon]\), \(final\)]\)=",Last@Elist-conf["groundstate"]];*)
(*ansatz/.\[Theta]vars*)
(*]*)


(* ::Input:: *)
(*VQEonVQD::usage="VQEonVQD[configuration]. Runs VQE on the virtual device.";*)
(*SetAttributes[VQEonVQD,HoldAll];*)
(*VQEonVQD[conf_]:=Module[{nqubit,\[Rho],\[Rho]work,\[Rho]\[Theta]k={},fev=0,cycleres,Elist={},ansatz={},\[Theta]vars=<||>,Ecur,IsDone,ncycle=0,greedy=True,finmsg,greedtrial,greedres,g,gatespercycle,ghash,gansatz,g\[Theta]vars,ng\[Theta]vars,tidx,gansatzid,Eold,gE,gElist,r,ibestg,elimmerge=0,gmerge=0,elimbfsmall=0,elimmetov=0,elimbf=0,wmsg="",dE,dkeys={"ansatz","\[Theta]vars","E","idx"},hkeys={"ansatz","\[Theta]vars","E","idx","hash"},aborted={},idx=0,eincr,compsucc=0,globalconverge=0,gdE,gEold,\[Theta]varsold,elist,failing=0,speedup=conf["speedupfirst"],IsConverge,defconf=conf,maxcost,abort=False,gradstep=conf["gradstep"],status="start",scost,probzeros=None, qmiavg=None,\[Rho]tmp={},sdate,nansatz,\[Theta]varsl={},\[Theta]varst,ge\[Theta],g\[Theta]iter=conf["g\[Theta]iter"],g\[Theta],minstat=""*)
(*}*)
(*,*)
(*nqubit=conf["nqubit"];*)
(*IsConverge[e_]:=If[Abs[e-conf["groundstate"]]<=conf["\[Epsilon]fin"],True,False];*)
(**)
(*(* pruning: keep at least 90% (or most of it for the first cycle) of improvement *)*)
(*maxcost:=With[{mcost=Ecur+conf["\[Epsilon]fin"],\[Delta]e=Abs[Ecur-Last@cycleres["E"]]},*)
(*If[ncycle>1,\[Delta]e*conf["pruningerror"]+Ecur, mcost]];*)
(**)
(**)
(*(* Initializations *)*)
(*{\[Rho],\[Rho]work}=CreateDensityQuregs[nqubit,2];*)
(**)
(*If[Length@conf["ansatz"]>0,*)
(*Print["Compilation with predetermined ansatz using gradient methode "<>conf["grad"]<>" @"<>DateString[]];*)
(*ansatz=conf["ansatz"];*)
(*If[Length@conf["\[Theta]vars"]>0,*)
(*\[Theta]vars=conf["\[Theta]vars"]*)
(*,*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*ansatz=ansatz/.\[Theta]:>Subscript[\[Theta], idx++];*)
(*\[Theta]vars=<|Table[Subscript[\[Theta], i]->RandomReal[{-conf["\[Theta]initrange"],conf["\[Theta]initrange"]}],{i,0,idx-1}]|>;*)
(*];*)
(**)
(*Monitor[*)
(*Ecur=costAvg[\[Rho],\[Rho]work,noisyAnsatz[ansatz,conf]/.\[Theta]vars,conf];*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*elist=RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep,conf["maxiter"]];*)
(*Elist=Join[Elist,elist];*)
(*(*{elimmerge,elimbfsmall,elimmetov,elimbf}+=*)
(*PruneGates[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur+conf["\[Epsilon]fin"],True,status];*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(**)
(*conf["gradstep"]*=0.01;*)
(*status="further relaxation";*)
(*elist=RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep];*)
(*Elist=Join[Elist,elist];*)*)
(*,*)
(*Column[{"cost:"<>ToString[Ecur,FortranForm]<>" nansatz="<>ToString[Length@ansatz],*)
(*"iteration:"<>ToString[fev]<>" gradstep:"<>ToString[gradstep,FortranForm],DrawCircuit[ansatz,nqubit],Values@\[Theta]vars,*)
(*"[status]"<>status}]*)
(*];*)
(*Table[DestroyQureg[q],{q,Flatten@{\[Rho],\[Rho]work,\[Rho]\[Theta]k}}];*)
(*Print[Column@{Ecur,DrawCircuit[ansatz,nqubit],ansatz,\[Theta]vars,ListPlot[Elist]}];*)
(*{Ecur,Elist,ansatz,\[Theta]vars,fev,{elimmerge,elimbfsmall,elimmetov,elimbf}}*)
(*,*)
(**)
(**)
(*(**** automatically generated ansatz ****)*)
(*Print["Compilation with automatically generated ansatz at "<>DateString[]<>" with grad "<>conf["grad"]];*)
(*sdate=Date[];*)
(*If[*)
(*conf["swapfabricdepth"]>0,*)
(*idx=0;*)
(*ansatz=SwapFabric[nqubit,conf["device"][DeviceType],conf["swapfabricdepth"]];*)
(*ansatz=ansatz/.\[Theta]:>Subscript[\[Theta], idx++];*)
(*Table[\[Theta]vars[Subscript[\[Theta], t]]=RandomReal[{-conf["\[Theta]initrange"],conf["\[Theta]initrange"]}],{t,0,idx-1}]; *)
(*,*)
(*{ansatz,\[Theta]vars,idx}={{},<||>,1};*)
(*];*)
(**)
(*Ecur=costAvg[\[Rho],\[Rho]work,noisyAnsatz[ansatz,conf]/.Normal@\[Theta]vars,conf];*)
(*gE=Ecur;*)
(*scost=Ecur;*)
(*fev++;*)
(*AppendTo[Elist,Ecur];*)
(*cycleres=Association[#->{}&/@dkeys];*)
(*Wrap[cycleres,ansatz,\[Theta]vars,Ecur,idx];*)
(**)
(*Monitor[*)
(*finmsg=Catch[ (* Ready for interruption *)*)
(*While[True, *)
(*++ncycle;*)
(*greedtrial=If[ncycle===1,conf["greedinessinit"],conf["greediness"]];*)
(*(*update the start cost *)*)
(*If[ncycle===2,scost=Ecur];*)
(*gatespercycle=dynNGates[scost,Ecur,conf["ngatesinit"],conf["groundstate"]];*)
(*(* clear old buffer *)*)
(*gElist=<||>; *)
(*greedres=Association[#->{}&/@hkeys];*)
(*Eold=cycleres["E"][[-1]];*)
(*If[Eold!= Ecur, Print["ERROR: Eold != Ecur", Eold,",",Ecur]];*)
(**)
(**)
(*For[g=1,g<=greedtrial, g++,*)
(*tidx=idx;*)
(*status="extend ansatz";*)
(*gansatz=ExtendAnsatz[tidx,conf,ansatz,gatespercycle];*)
(*ghash=Hash[gansatz];*)
(*If[MemberQ[greedres["hash"],ghash],*)
(*wmsg="I have tried this ansatz before. ";*)
(*Continue[];*)
(*];*)
(**)
(*(* brute force initial \[Theta] guess *)*)
(*\[Theta]varsl={};*)
(*ge\[Theta]=Table[*)
(*\[Theta]varst=\[Theta]vars;*)
(*Table[\[Theta]varst[Subscript[\[Theta], k]]=RandomReal[{-conf["\[Theta]initrange"],conf["\[Theta]initrange"]}],{k,idx,tidx-1}];*)
(*AppendTo[\[Theta]varsl,\[Theta]varst];*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]varst,\[Rho]\[Theta]k];*)
(*g\[Theta]=costAvg[\[Rho],\[Rho]work,noisyAnsatz[gansatz,conf]/.Normal@\[Theta]varst,conf];*)
(*RelaxAnsatz[conf,fev,gansatz,\[Theta]varst,\[Rho],\[Rho]work,\[Rho]\[Theta]k,g\[Theta],gradstep,g\[Theta]iter];*)
(*g\[Theta]*)
(*,{conf["greed\[Theta]"]}];*)
(**)
(*g\[Theta]vars=\[Theta]varsl[[First@Ordering[ge\[Theta],1]]];*)
(*gE=Min[ge\[Theta]];*)
(**)
(*gmerge+=MergeGates[gansatz,g\[Theta]vars];*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,g\[Theta]vars,\[Rho]\[Theta]k];*)
(**)
(*(* Relax the newly obtained parameters. *)*)
(*status="relaxation in greedy";*)
(*gElist[g]=RelaxAnsatz[conf,fev,gansatz,g\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,gE,gradstep,conf["maxgreediter"]];*)
(**)
(*(* wrap and record the results *)*)
(*Wrap[greedres,gansatz,g\[Theta]vars,gE,tidx,ghash];*)
(**)
(*(* terminate if the target energy is found *)*)
(*If[IsConverge[gE],Break[]];*)
(**)
(*(* release greedy-memory *)*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*]; (* END OF GREEDY TRIAL*)*)
(**)
(*(* Pick the best line to continue optimization *)*)
(*ibestg=First@Flatten[Position[greedres["E"],Min@greedres["E"]]];*)
(*{ansatz,\[Theta]vars,Ecur,idx}=greedres[#][[ibestg]]&/@dkeys;*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*Elist=Join[Elist,gElist[ibestg]];*)
(**)
(*(* further optimisation before judge *)*)
(*elist=RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep,conf["maxiter"]];*)
(*Elist=Join[Elist,elist];*)
(**)
(*If[IsConverge[Ecur],*)
(*Wrap[cycleres,ansatz,\[Theta]vars,Ecur,idx];*)
(*Throw["Circuit within target precision is found"]*)
(*];*)
(**)
(*If[(*** Improves ****)*)
(*Ecur<Last@cycleres["E"],*)
(**)
(*(* improves: pathetic *)*)
(*If[*)
(*Abs[Last@cycleres["E"]-Ecur]<=conf["\[Epsilon]fin"], *)
(*minstat="[improved pathetically, aborted]";*)
(**)
(*wmsg="I might be converging. ";*)
(*globalconverge+=1;*)
(*wmsg=wmsg<>"Abort cycle "<>ToString[ncycle]<>". Pathetic result. ";*)
(**)
(*{ansatz,\[Theta]vars,Ecur,idx}=cycleres[#][[-1]]&/@dkeys;*)
(*AppendTo[aborted,ncycle];*)
(*minstat=minstat<>AdjustSpeed[conf,defconf,speedup,ncycle];*)
(**)
(*,*)
(*(* improves: good *)*)
(*minstat="[improved well, updated]";*)
(*globalconverge=0; failing=0;*)
(*wmsg="Cycle "<>ToString[ncycle]<>" is completed with significant improvement. ";*)
(*(* record *)*)
(*wmsg=wmsg<>"Pruning and perfecting cycle "<>ToString[ncycle]<>", with maxcost:"<>ToString[maxcost,FortranForm]<>"; current cost="<>ToString[Ecur,FortranForm];*)
(**)
(*{elimmerge,elimbfsmall,elimmetov,elimbf}+=*)
(*PruneGates[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,maxcost,True,status];*)
(*AppendTo[Elist,Ecur];*)
(*AdjustAngles[\[Theta]vars];*)
(*status="perfecting";*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*elist=RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep];*)
(*Elist=Join[Elist,elist];*)
(*Wrap[cycleres,ansatz,\[Theta]vars,Ecur,idx];*)
(*];*)
(**)
(*,*)
(*(*** Equals/Worse ****)*)
(*minstat="[worse, aborted]";*)
(*failing+=1;*)
(*wmsg="Abort cycle "<>ToString[ncycle]<>". Worse or equal result. ";*)
(*{ansatz,\[Theta]vars,Ecur,idx}=cycleres[#][[-1]]&/@dkeys;*)
(*AppendTo[aborted,ncycle];*)
(*minstat=minstat<>AdjustSpeed[conf,defconf,speedup,ncycle];*)
(**)
(*];*)
(**)
(*Print["@cycle"<>ToString[ncycle]<>":"<>DateString[]<>", fev:"<>ToString[fev]<>", <E>: "<>ToString[Ecur,FortranForm]," nansatz: "<>ToString[Length@ansatz]," merged-small\[Theta]-metric-bf-gmerged: "<>ToString[{elimmerge,elimbfsmall,elimmetov,elimbf,gmerge}]<>minstat];*)
(*(* Getting converged or failing *)*)
(*If[ failing >= conf["globalconverge"], Throw["I keep failing to lower the energy. "]];*)
(*If[globalconverge>= conf["globalconverge"], Throw["Compilation is either converging or stuck. "]];*)
(*If[IsConverge[Ecur],Throw["Circuit within target precision is found"]];*)
(*]*)
(*];*)
(*wmsg=finmsg;*)
(*wmsg=wmsg<>" Final pruning ... we are almost there";*)
(**)
(*(* maxcost is simply the final target *)*)
(*AdjustAngles[\[Theta]vars];*)
(**)
(*{elimmerge,elimbfsmall,elimmetov,elimbf}+=PruneGates[conf,fev,Ecur,gradstep,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,True,status];*)
(* *)
(*status="perfecting";*)
(*AppendTo[Elist,Ecur];*)
(*AdjustAngles[\[Theta]vars];*)
(*AdjustQuregs\[Rho]\[Theta]k[nqubit,\[Theta]vars,\[Rho]\[Theta]k];*)
(*elist=RelaxAnsatz[conf,fev,ansatz,\[Theta]vars,\[Rho],\[Rho]work,\[Rho]\[Theta]k,Ecur,gradstep];*)
(**)
(*Wrap[cycleres,ansatz,\[Theta]vars,Ecur,idx];*)
(*,*)
(*Column[{"ncycle:" <>ToString@ncycle<>", fev:"<>ToString@fev<>", globalconvergence: "<>ToString[globalconverge]<>", failing="<>ToString[failing],*)
(*"Eliminations -- merged: "<>ToString[elimmerge]<>", bruteforce small\[Theta]:"<>ToString[elimbfsmall]<>*)
(*", metric: "<>ToString[elimmetov]<>", bruteforce:"<>ToString[elimbf]<>", gmerge:"<>ToString[gmerge],*)
(*"gatespercycle, greediness, \[Alpha]tikhonov, gradstep: "<>ToString[{gatespercycle,conf["greediness"],ToString[conf["\[Alpha]tikhonov"],FortranForm],ToString[gradstep,FortranForm]}],*)
(*"groundstate="<>ToString[conf["groundstate"],FortranForm]<>"; \[Delta]\[Epsilon]="<>ToString[Ecur-conf["groundstate"],FortranForm]<>"; ngates:"<>ToString[Length@ansatz],*)
(*"cost="<>ToString[Ecur,FortranForm],*)
(*"Greedy section: gE="<>ToString[gE,FortranForm]<>", g\[Theta]="<>ToString[g\[Theta],FortranForm],*)
(*greedres["E"],status<>" -- "<>wmsg,*)
(*DrawCircuit[Join[conf["initcirc"],ansatz,conf["virtualmeas"]]/.CustomGatesDraw,nqubit]*)
(*}]*)
(*];*)
(*Table[DestroyQureg[q],{q,Flatten@{\[Rho],\[Rho]work,\[Rho]\[Theta]k}}];*)
(*{DateDifference[sdate,Date[],"Minutes"],Ecur,Elist,Flatten@{conf["initcirc"],ansatz,conf["virtualmeas"]},\[Theta]vars,finmsg,ncycle,fev,aborted,cycleres,elimmerge,elimbfsmall,elimmetov,elimbf}*)
(*]*)
(*]*)


(* ::Input:: *)
(*FormatHamiltonian::usage="Format the hamiltonian from qiskit;daniel's format";*)
(*FormatHamiltonian[filename_]:=Module[{stringham,ham,nterms,nqubits},*)
(*stringham=Import[filename];*)
(*ham=ToExpression[stringham];*)
(*nqubits=1+Select[Flatten[Level[#,-1]&/@Flatten@ham],NumericQ[#]&]//Max;*)
(*ham=Table[If[Length[term]<2,{term[[1]],Subscript[Id, nqubits-1]},term],{term,ham}];*)
(*nterms=Length@ham;*)
(*{Total@Apply[Times,ham,1],nterms,nqubits}*)
(*]*)
